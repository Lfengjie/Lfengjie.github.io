---
layout: post
title: "ceph-pg哈希"
date: 2019-09-26
description: "ceph pg 哈希"
tag: 博客 
---

## 序言
### ceph简介
Ceph 是一个统一的分布式存储系统，设计初衷是提供较好的性能、可靠性和可扩展性。底层的rados分布式存储是ceph的精华所在，ceph以rados为基础在上层封装了对象、块、文件存储接口。客户端可以通过ceph提供的librados库直连rados集群，待存对象通过计算获取指定机器，然后将数据发送到该机器上存储。因为都是通过计算的方式，所以rados不需要维护一个中心table来存储对象所在的位置，这种计算型的方式不仅快速，而且能够节省节点的资源。
下图为ceph的总体框架图:

![ceph架构](/images/posts/ceph.png)

### 数据如何映射
Ceph对集群中所有存储资源进行池化管理，对象通过计算直接映射到底层的osd中，为了更好的管理和映射数据，ceph有如下的概念。
- object: 用户需要存储的对象，可以是文档、视频、音频等等文件，用户在存储的时候需要指定唯一的对象名。
- pool：资源池，这是一个虚拟概念，一个集群可以分出多个pool，也可以使用单个pool,但是必须有一个pool。 用户可以针对不同的pool指定不同的CRUSH规则，也可以针对不同的pool指定不同的数据冗余策略。
- pg：全称 placement groups, 一个pool对应多个pg, 通过hash对象会存储到pool中的特定pg中。在创建pool的时候就要把pg数量规划好。pg数量只可以增大不可以缩小。
- osd：最终的数据都是存储在特定的osd上，一般情况下一个osd会管理一块磁盘。

对象的映射逻辑架构如下：

![ceph-object映射过程](/images/posts/ceph-object映射过程.png)


## pg哈希算法
object通过hash对应到不同的pg中，ceph使用掩码的方式来代替取模操作。例如PG数目对应的最高比特位为n，则其掩码为2^n -1, 将某个对象映射到PG时，直接使用 object & (2^n -1)即可。这种直接与的方式其实就是取object二进制的后 n 位作为pg number，这种方式不仅高效，而且运算速度快。
可能有人会问这个n是怎么来的，其实n就是PG数二进制表示中1最高位的1。ceph中如果设置PG数目为a，那么程序会得到一个最小的n,使 a <= 2^n，例如：(a=12, n=4), (a=16, n=4), (a=17, n=5)，以此类推。
但是这种方案存在一个潜在的问题，如果运维人员设置的PG数是2的幂次方的话，那么这种方案比较完美。如果PG数目不是2的幂次方的话这种映射会产生空穴，即将某些对象映射到一些实际上不存在的PG上。如下图所示:

![ceph pg掩码](/images/posts/ceph-掩码事例.png)

上图中如果如果PG数目为14，但是n=4,直接hash的话会产生 0~15 共计16中不同的结果，但是12 ~ 15这4个PG是不存在的，为了解决这个问题ceph做了降级方案。因为 n 为PG数的最高位，因此可以得到如下的方程式。

```
2^(n-1) < PG数 <= 2^n
```

由此可得 [0,2^(n-1)]内PG一定是存在的，可以通过 object & 2^(n-1) 来将那些实际上不存在的PG重新映射到这个小的区间内，如下图所示:

![ceph-object重新映射过程](/images/posts/ceph-object映射过程-重新映射)

如上图所示，ceph会将映射出不存在的PG重新映射到前面存在的区间中。所以如果ceph集群设置的PG数目不是2的幂次方的话，可能会造成中间某一段的PG所承载的数据高于其它PG，例如：PG数为12时会造成4，5，6，7四个PG所承载的对象数是其它PG的两倍，所以集群在稳定时PG数最好的2的幂次方。

### PG扩容
在现实使用中如果

## 直接取模的弊端


